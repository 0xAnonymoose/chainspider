import { Inspector } from '../chainspider.mjs';
import { applySignature, prepareContract } from '../lib/signature.mjs';

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

export class MalwareChecker extends Inspector {
  constructor(cs) { 
    super(cs, 'MalwareChecker');

    /* using __dirname allows parcel to inline the asset, but __dirname is not valid ES6 */
    try {
      this.signatures = JSON.parse(fs.readFileSync(__dirname+'/../sigs/blockchain-malware-signatures.json','utf-8'));
    } catch(e) {
      let dirName = path.dirname(fileURLToPath(import.meta.url));
      this.signatures = JSON.parse(fs.readFileSync(dirName+'/../sigs/blockchain-malware-signatures.json','utf-8'));
    }
    
    this.subscribe('Contract', 'is-token');
    this.panel('MalwareReport', MalwareChecker.panelMalware);
  }
  
  async onRelation(r) {
    let addr = r.src_node.relative('is-contract').val;
    let code = r.src_node.val.code;
    let source = r.src_node.val.source;
    
    let target = prepareContract(addr, code, source);
    let anyMatch = false;
    let count = 0;
    
    for (let mw of Object.keys(this.signatures)) {
      let { malwareName, malwareTags, signatures } = this.signatures[mw];
      if (!malwareName) { continue; }
      let match = false;
      
      for (let sig of signatures) {
        if (sig.signatureType == 'source') { continue; }
        let res = applySignature( sig, target );
        match = match || res.match;
        count++;
      }
      
      if (match) {
        anyMatch = true;
        let w = this.cs.createNode( 'MalwareReport', { 'status': 'match', malwareName, malwareTags });
        this.cs.reportMessage( this.id, addr, -100, 'Token '+r.dst_node.val.name+' is malware: '+malwareName, w );
        this.cs.createRelation( r.dst_node, 'malware-check', w );
      }
    }
    
    if (!anyMatch) {
      let w = this.cs.createNode( 'MalwareReport', { 'status': 'pass', 'signatures_checked': count });
      this.cs.reportMessage( this.id, addr, 0, 'Token '+r.dst_node.val.name+' passed '+count+' malware checks.', w );
      this.cs.createRelation( r.dst_node, 'malware-check', w );
    }
    
  }

  static panelMalware(node) {
    if (node.val.status == 'match') {
      return `<h2 class='text-color: red'>MALWARE DETECTED: ${node.val.malwareName}</h2>${node.val.malwareTags.join('<br>')}`;
    } else if (node.val.status == 'pass') {
      return `<h2>This token has passed malware checks.</h2><p>Note that the signature database is still small while ChainSpider is in beta, so this should result should NOT be replied upon!`;
    }
  }
  
  static getStyles() {
    return [
	    {
	          selector: 'node[type="MalwareReport"][status="pass"]',
		  style: {
		    'height': 32,
		    'width': 32,
		    'shape': 'round-rectangle',
		    'background-image': require('../icons/passed-32.png'),
		    'background-color': 'white'
		  }
	    },
	    {
	          selector: 'node[type="MalwareReport"][status="match"]',
		  style: {
		    'height': 32,
		    'width': 32,
		    'shape': 'round-rectangle',
		    'border-width': '1px',
		    'border-color': 'red',
		    'background-image': require('../icons/error.png'),
		    'background-color': 'white'
		  }
	    }
	    ];    
  }
  
}
